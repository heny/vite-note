import{o as n,c as s,d as a}from"./app.0bfd9210.js";const p='{"title":"js-15 面向对象、this","description":"","frontmatter":{},"headers":[{"level":2,"title":"一、对象组成","slug":"一、对象组成"},{"level":2,"title":"二、对象读写","slug":"二、对象读写"},{"level":2,"title":"三、对象遍历","slug":"三、对象遍历"},{"level":2,"title":"四、对象函数调用","slug":"四、对象函数调用"},{"level":2,"title":"五、创建普通对象","slug":"五、创建普通对象"},{"level":2,"title":"六、原生对象","slug":"六、原生对象"},{"level":2,"title":"七、instanceof","slug":"七、instanceof"},{"level":2,"title":"八、工厂模式","slug":"八、工厂模式"},{"level":2,"title":"九、构造函数","slug":"九、构造函数"},{"level":2,"title":"十、原型对象","slug":"十、原型对象"},{"level":3,"title":"constructor","slug":"constructor"},{"level":3,"title":"_proto_","slug":"proto"},{"level":3,"title":"判断原型与实例的关系","slug":"判断原型与实例的关系"},{"level":3,"title":"原型链","slug":"原型链"},{"level":3,"title":"更简单的原型语法","slug":"更简单的原型语法"},{"level":3,"title":"原型的动态性","slug":"原型的动态性"},{"level":3,"title":"原生对象的原型","slug":"原生对象的原型"},{"level":3,"title":"原型对象的问题","slug":"原型对象的问题"},{"level":2,"title":"十一、混合模式","slug":"十一、混合模式"},{"level":2,"title":"十二、动态原型模式","slug":"十二、动态原型模式"},{"level":2,"title":"十三、寄生构造函数模式","slug":"十三、寄生构造函数模式"},{"level":2,"title":"十四、稳妥构造函数模式","slug":"十四、稳妥构造函数模式"},{"level":2,"title":"十五、命名空间","slug":"十五、命名空间"},{"level":2,"title":"十六、继承","slug":"十六、继承"},{"level":3,"title":"原型链继承","slug":"原型链继承"},{"level":3,"title":"构造函数式继承","slug":"构造函数式继承"},{"level":3,"title":"组合式继承","slug":"组合式继承"},{"level":3,"title":"原型式继承","slug":"原型式继承"},{"level":3,"title":"寄生式继承","slug":"寄生式继承"},{"level":3,"title":"寄生组合式继承","slug":"寄生组合式继承"},{"level":3,"title":"extends","slug":"extends"},{"level":2,"title":"十七、call apply bind（修改this指向）","slug":"十七、call-apply-bind（修改this指向）"},{"level":3,"title":"call","slug":"call"},{"level":3,"title":"apply","slug":"apply"},{"level":3,"title":"bind  IE9+","slug":"bind-ie9"},{"level":2,"title":"高频面试题","slug":"高频面试题"}],"relativePath":"src/frontend/Javascript/js-15 面向对象、this.md","lastUpdated":1620547001399}',t={},o=a('<h1 id="js-15-面向对象、this"><a class="header-anchor" href="#js-15-面向对象、this" aria-hidden="true">#</a> js-15 面向对象、this</h1><p>ECMAScript有两种开发模式；</p><p>①函数式（过程化）；</p><p>②面向对象（OOP）；</p><p>面向对象三个基本特征：封装、继承、多态</p><h2 id="一、对象组成"><a class="header-anchor" href="#一、对象组成" aria-hidden="true">#</a> 一、对象组成</h2><p>对象由属性和方法组成</p><h2 id="二、对象读写"><a class="header-anchor" href="#二、对象读写" aria-hidden="true">#</a> 二、对象读写</h2><p>读：对象.key 或者 对象[&#39;key&#39;]</p><p>写：对象.key=新值 或者 对象[&#39;key&#39;]=新值</p><h2 id="三、对象遍历"><a class="header-anchor" href="#三、对象遍历" aria-hidden="true">#</a> 三、对象遍历</h2><p>for in循环，遍历对象里面的每一个参数；</p><h2 id="四、对象函数调用"><a class="header-anchor" href="#四、对象函数调用" aria-hidden="true">#</a> 四、对象函数调用</h2><p>obj.fn() 如果一个函数是被对象调用的，那这个函数的this是对象；</p><div class="language-js"><pre><code><span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token punctuation">{</span> <span class="token function-variable function">fn</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\nobj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//obj调用的;</span>\n<span class="token keyword">var</span> f<span class="token operator">=</span> obj<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>\n<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//这里的this指向window 默认写法是:  window.f() window调用</span>\n</code></pre></div><h2 id="五、创建普通对象"><a class="header-anchor" href="#五、创建普通对象" aria-hidden="true">#</a> 五、创建普通对象</h2><div class="language-js"><pre><code><span class="token comment">//对象字面量</span>\n<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> key<span class="token operator">:</span> value<span class="token punctuation">}</span>\n\n<span class="token comment">// 实例化:</span>\n<span class="token keyword">var</span> <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><h2 id="六、原生对象"><a class="header-anchor" href="#六、原生对象" aria-hidden="true">#</a> 六、原生对象</h2><p>原生创建好的9个对象：Number、String、Boolean、Array、Object、Function、RegExp、Date、Error；直接使用就可以了；</p><p>万物皆对象，Object就相当于人类的地球，再上面就是null，整个宇宙</p><h2 id="七、instanceof"><a class="header-anchor" href="#七、instanceof" aria-hidden="true">#</a> 七、instanceof</h2><p>标识实例和对象是否在一个原型链上（实例是否是这个对象创建的）；</p><p>比如：arr instanceof Array（arr是由Array创建的）返回true；</p><p>也可以：this instanceof F 判断this是否指向该函数;</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">f</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 如果使用new, 则this指向f;  new出来的函数指向创建他的函数;</span>\n</code></pre></div><h2 id="八、工厂模式"><a class="header-anchor" href="#八、工厂模式" aria-hidden="true">#</a> 八、工厂模式</h2><ol><li>工厂模式创建对象其实就是一个封装函数；</li></ol><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//1. 准备原料</span>\n    obj<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>   <span class="token comment">//2. 加工</span>\n    obj<span class="token punctuation">.</span><span class="token function-variable function">eat</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;foot&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> obj    <span class="token comment">//3. 出厂</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token string">&#39;张三&#39;</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 可以无限调用;  和调用函数是一样的；</span>\n</code></pre></div><p>这个s和fn是没有关系的，因为s是对象创建出来的，和函数是没有关系的;</p><p>s != fn;</p><ol start="2"><li>工厂模式的问题：</li></ol><p>工厂模式解决了重复实例化的问题，但还有一个问题，那就是识别问题，因为根本无法搞清楚他们到底是哪个对象的实例；不能标识实例是由谁创建的；</p><h2 id="九、构造函数"><a class="header-anchor" href="#九、构造函数" aria-hidden="true">#</a> 九、构造函数</h2><p>构造函数：function 类名(){};</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">eat</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;foot&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&#39;康哥&#39;</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   \n<span class="token comment">// 使用new出来的始终是一个对象,所以不需要在函数内部声明一个空对象;</span>\n</code></pre></div><ol><li>构造函数的特点：</li></ol><ul><li>构造函数名首字母大写（为了区分普通函数）</li><li>构造函数方法没有显示的创建对象 (new Object())； （创建时不需要像工厂模式那样new object，就可以直接创建）；</li><li>直接将属性和方法赋值给 this 对象</li><li>没有return语句，不需要返回对象</li><li>通过构造函数创建对象，必须使用new运算符（如果直接调用和普通函数一样）</li></ul><ol start="3"><li><p>构造函数也能够批量生产，而且通过构造函数创建的对象，能区分开当前的实例是由哪个对象创建的，可以利用instanceof验证；</p></li><li><p>构造函数的问题：</p></li></ol><p>同一个方法，因为对象不同，所存储的位置也不同，如果有多个对象，则要分别存储多次，占用不必要的内存。</p><p>两个对象和两个数组和两个函数是不相同的，都是引用类型，引用类型的比较，比较的是地址，地址是不一样的，所以是不等；地址不同，如果大量的存储，则会导致内存空间爆满；</p><p>即使对象里面有数据也是不等的；</p><div class="language-js"><pre><code><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">//false</span>\n<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">===</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">//false</span>\n<span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">===</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">//false</span>\n\n<span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">&#39;h&#39;</span><span class="token punctuation">}</span>\n<span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">&#39;h&#39;</span><span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1 <span class="token operator">===</span> obj2<span class="token punctuation">)</span>  <span class="token comment">//false</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>name <span class="token operator">===</span> obj2<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">//true  可以比较对象的具体值;</span>\n</code></pre></div><h2 id="十、原型对象"><a class="header-anchor" href="#十、原型对象" aria-hidden="true">#</a> 十、原型对象</h2><blockquote><p>每个对象都会有自己的原型对象，是最顶层类型定义的方法和属性。如 Number 对象的原型对象中定义了很多的方法和属性，则所有的number对象都能使用这个方法和属性。</p></blockquote><h3 id="constructor"><a class="header-anchor" href="#constructor" aria-hidden="true">#</a> constructor</h3><p>只要创建一个对象，就会有一个原型对象（prototype），这个原型对象里面有一个constructor（构造器），指向这个构造函数，原型对象里面所有属性和方法对构造函数的实例都是可见的；</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nobj<span class="token punctuation">.</span>constructor  <span class="token comment">//function f(){}</span>\n</code></pre></div><p>原型的作用：实现数据共享，继承，都是为了节省内存空间； 如果属性和方法都需要共享，就把他们都添加到原型当中；</p><h3 id="proto"><a class="header-anchor" href="#proto" aria-hidden="true">#</a> _<em>proto</em>_</h3><p>是隐式原型，指向创建他的函数的原型，原型对象需要用类型名调用，如Number.prototype。</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nobj<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">F</span><span class="token punctuation">.</span>prototype   <span class="token comment">//true</span>\n\n<span class="token comment">// 给原型添加新的属性和方法</span>\nobj<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span>   <span class="token comment">//使用创建出来的对象添加;</span>\n<span class="token class-name">F</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span>   <span class="token comment">//使用原型添加;</span>\n</code></pre></div><p>当我们修改了原型对象的方法以后，所有这类对象再调用这个方法时都是修改之后的。因为原型对象中的内容是共享的。</p><div class="language-js"><pre><code><span class="token class-name">String</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">charAt</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">index</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;原型&#39;</span><span class="token operator">+</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">&#39;web&#39;</span><span class="token punctuation">;</span>\nstr<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 原型 1 不再是获取的操作</span>\n</code></pre></div><h3 id="判断原型与实例的关系"><a class="header-anchor" href="#判断原型与实例的关系" aria-hidden="true">#</a> 判断原型与实例的关系</h3><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><ul><li><code>obj.constructor === F</code> //true 使用构造器判断;</li><li><code>obj.__proto__ === F.prototype</code> //true 使用原型对比;</li><li><code>F.prototype.isPropertyOf(obj)</code> // true 使用isPropertyOf；</li><li><code>Object.getPropertyOf(obj) === F.prototype</code> // 使用getPropertyOf</li><li><code>obj instanceof F</code> //使用instanceof来判断;</li></ul><h3 id="原型链"><a class="header-anchor" href="#原型链" aria-hidden="true">#</a> 原型链</h3><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token comment">//创建构造函数之后就有一个原型对象；</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Student\n<span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//实例之后p1就可以访问到原型对象的属性和方法</span>\n\n<span class="token comment">//p1实例化Student之后是一个空对象，空对象里面没有，就找构造函数constructor，构造函数找不到就找原型对象prototype，如果原型对象也没有，就undefined；</span>\n</code></pre></div><p>理论：相当于儿子(p1)没有钱，就找爸(Student.prototype)要;</p><p><img src="https://notecdn.heny.vip/images/js-15_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81this-01.png" alt="image"></p><p><img src="https://notecdn.heny.vip/images/js-15_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81this-02.png" alt="image"></p><ol start="5"><li><p>通过原型创建的对象，对象的方法和属性是共享的，只会存储一次，因此能够解决内存浪费的问题，但是会出现一个新的问题，原型创建的对象的属性不能传参，都是固定的值。这样的话就不能创建不同的对象了。</p></li><li><p>构造函数的优点：两个不同的变量使用同一个原型链，他们的地址都是相同的，大量储存不会占用内存空间；</p></li></ol><p>原型链：</p><p><img src="https://notecdn.heny.vip/images/js-15_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81this-03.png" alt="image"></p><p>原型链：自己的实例化---自己的构造函数---自己的原型---父类的构造函数----父类的原型---Object的原型---null；</p><h3 id="更简单的原型语法"><a class="header-anchor" href="#更简单的原型语法" aria-hidden="true">#</a> 更简单的原型语法</h3><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>\n    name<span class="token operator">:</span> <span class="token string">&#39;hny&#39;</span><span class="token punctuation">,</span>\n    <span class="token function-variable function">sayName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 通过defineProperty写入constructor, 禁止in遍历;</span>\nObject<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>Person<span class="token punctuation">,</span> <span class="token string">&#39;constructor&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    enumerable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n    value<span class="token operator">:</span> Person <span class="token comment">// 将constructor指定;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><h3 id="原型的动态性"><a class="header-anchor" href="#原型的动态性" aria-hidden="true">#</a> 原型的动态性</h3><p>由于原型中查找值是搜索，因此对原型对象所做的任何修改都能够立即从实例上反映出来</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token keyword">var</span> friend <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&#39;hi&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\nfriend<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// hi</span>\n</code></pre></div><p>如果是重写原型对象，则不一样，由于调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另一个对象等于切断了构造函数与最初原型之间的联系了；</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token keyword">var</span> friend <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>\n    consturctor<span class="token operator">:</span> Person<span class="token punctuation">,</span>\n    name<span class="token operator">:</span> <span class="token string">&#39;hny&#39;</span><span class="token punctuation">,</span>\n    <span class="token function-variable function">sayName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\nfriend<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// error</span>\n</code></pre></div><h3 id="原生对象的原型"><a class="header-anchor" href="#原生对象的原型" aria-hidden="true">#</a> 原生对象的原型</h3><p>所有的原生引用类型（Object、Array、String）都在其构造函数的原型上定义了方法，我们也可以直接扩展原生对象的原型，供在当前环境下使用；（不建议在产品化的程序中修改原生对象的原型）</p><p>扩展String: 如果string里面没有trim这个方法，则创建一个trim方法</p><div class="language-js"><pre><code><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">String</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>trim<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token class-name">String</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">trim</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token comment">//这个this表示，谁调用的这个函数谁就谁</span>\n        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\\s+|\\s+$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span><span class="token string">&#39;&#39;</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>  \n\n<span class="token comment">// 扩展Array:  如果array存在则不添加方法;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>indexOf<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">indexOf</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n     <span class="token comment">//判断是否传入2个值</span>\n    index <span class="token operator">=</span> <span class="token keyword">typeof</span> index <span class="token operator">==</span> <span class="token string">&#39;undefiend&#39;</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> index<span class="token punctuation">;</span>\n    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span>index<span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> value<span class="token punctuation">)</span> <span class="token keyword">return</span> i\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>String、Array可以不通过原型调用，因为后台会调用其基本包装函数创建；</p><h3 id="原型对象的问题"><a class="header-anchor" href="#原型对象的问题" aria-hidden="true">#</a> 原型对象的问题</h3><p>在包含引用类型值的属性来说，就会出现很大的问题了；</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>\n    constructor<span class="token operator">:</span> Person<span class="token punctuation">,</span>\n    friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;Shelby&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;Court&#39;</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">var</span> Person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nperson1<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&#39;Van&#39;</span><span class="token punctuation">)</span>\nperson1<span class="token punctuation">.</span>friends <span class="token comment">// </span>\nperson2<span class="token punctuation">.</span>friends <span class="token comment">// [&#39;Shelby&#39;, &#39;Court&#39;, &#39;Van&#39;]</span>\nperson1<span class="token punctuation">.</span>friends <span class="token operator">===</span> person2<span class="token punctuation">.</span>friends <span class="token comment">// 指针相同;</span>\n</code></pre></div><h2 id="十一、混合模式"><a class="header-anchor" href="#十一、混合模式" aria-hidden="true">#</a> 十一、混合模式</h2><p>创建自定义类型的最常见的方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存；</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n    <span class="token keyword">this</span><span class="token punctuation">.</span>friends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;Shelby&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;Court&#39;</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>\n    constructor<span class="token operator">:</span> Person<span class="token punctuation">,</span>\n    <span class="token function-variable function">sayName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&#39;hny&#39;</span><span class="token punctuation">)</span>\n<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&#39;heny&#39;</span><span class="token punctuation">)</span>\nperson1<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&#39;Van&#39;</span><span class="token punctuation">)</span>\nperson2<span class="token punctuation">.</span>friends <span class="token comment">// [&#39;Shelby&#39;, &#39;Court&#39;]</span>\n</code></pre></div><h2 id="十二、动态原型模式"><a class="header-anchor" href="#十二、动态原型模式" aria-hidden="true">#</a> 十二、动态原型模式</h2><ol><li>一般创建对象用混合模式就够了，但是严格来说这种方式破坏了封装性，所以还可以使用动态混合模式创建，将原型方法也写到构造函数当中。</li><li>动态混合创建每创建一个对象就会执行一次原型，所以动态原型模式需要做判断，判断是还存在这个原型，如果存在则不添加；</li><li>判断只会在初次调用构造函数时才会执行；</li></ol><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n     <span class="token comment">// 判断是否存在，不存在则添加</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span><span class="token punctuation">.</span>eat <span class="token operator">==</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">eat</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;rice&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 实例对象</span>\n<span class="token keyword">var</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&#39;lishi&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&#39;zhangsan&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span>name<span class="token punctuation">,</span> s2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lishi zhangsan</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span>eat<span class="token punctuation">,</span>s2<span class="token punctuation">.</span>eat<span class="token punctuation">)</span>  <span class="token comment">//rice</span>\n</code></pre></div><h2 id="十三、寄生构造函数模式"><a class="header-anchor" href="#十三、寄生构造函数模式" aria-hidden="true">#</a> 十三、寄生构造函数模式</h2><p>寄生构造函数就是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；</p><p>构造函数返回的对象与构造函数外部创建的对象没有什么不同，不能依赖instanceof确定对象的类型，可以使用其他模式时不建议使用寄生构造函数模式；</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    o<span class="token punctuation">.</span>name <span class="token operator">=</span> name\n    o<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> o\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&#39;hny&#39;</span><span class="token punctuation">)</span>\nperson1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// hny</span>\n</code></pre></div><h2 id="十四、稳妥构造函数模式"><a class="header-anchor" href="#十四、稳妥构造函数模式" aria-hidden="true">#</a> 十四、稳妥构造函数模式</h2><p>稳妥对象指没有公共属性，而且其方法也不引用this对象。稳妥对象最适合在一些安全的环境中，或者在防止数据被其他应用程序改动时使用；</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    o<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token function">alert</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> o\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&#39;hny&#39;</span><span class="token punctuation">)</span>\nperson1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// hny</span>\n</code></pre></div><p>上面的例子中，除了调用sayName没有其他方法访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数的原始数据；使得它非常适合在某些安全执行环境下使用；如：ADsafe、Caja ；</p><h2 id="十五、命名空间"><a class="header-anchor" href="#十五、命名空间" aria-hidden="true">#</a> 十五、命名空间</h2><p>一般名字都是见名知意的，但是如果代码足够复杂，或者使用了很多的第三方框架和插件，变量名不够用了，我们可以使用命名空间即把同一类方法包在一起。</p><div class="language-js"><pre><code><span class="token keyword">var</span> fnObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\nfnObj<span class="token punctuation">.</span>common <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">//公共的函数;</span>\nfnObj<span class="token punctuation">.</span>common<span class="token punctuation">.</span><span class="token function-variable function">getUser</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">&#39;lishi&#39;</span><span class="token punctuation">}</span>\n<span class="token comment">// 将方法写进对象里面;</span>\n</code></pre></div><h2 id="十六、继承"><a class="header-anchor" href="#十六、继承" aria-hidden="true">#</a> 十六、继承</h2><h3 id="原型链继承"><a class="header-anchor" href="#原型链继承" aria-hidden="true">#</a> 原型链继承</h3><blockquote><p>将子的原型指向父的实例化</p></blockquote><div class="language-js"><pre><code><span class="token class-name">B</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><p>缺点：子类不能传参。（父类还是可以传参的，通过new时）</p><h3 id="构造函数式继承"><a class="header-anchor" href="#构造函数式继承" aria-hidden="true">#</a> 构造函数式继承</h3><blockquote><p>又叫对象冒充继承</p></blockquote><p>在B当中把A的所有代码实现</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token constant">A</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n</code></pre></div><p>缺点：不能继承父类原型上的属性和方法，只能继承构造函数的属性和方法。</p><h3 id="组合式继承"><a class="header-anchor" href="#组合式继承" aria-hidden="true">#</a> 组合式继承</h3><p>组合继承也叫伪经典继承，用得最多的是组合式继承；</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token constant">A</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span> <span class="token punctuation">}</span>\n<span class="token class-name">B</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> <span class="token constant">B</span>\n  <span class="token comment">//自己没有constructor,因此重写constructor</span>\n</code></pre></div><p>缺点：创建的实例和原型上，存在两份相同的属性；因为在apply时复制了构造函数的属性和方法，在new 时又实例化了属性和方法，主要是为了复制原型的方法；</p><p>如果单独调用apply进行复制构造函数的，是不会存在两种方法和属性的；</p><p><img src="https://notecdn.heny.vip/images/js-15_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81this-04.png" alt="image"></p><h3 id="原型式继承"><a class="header-anchor" href="#原型式继承" aria-hidden="true">#</a> 原型式继承</h3><p>ES5可以直接使用<code>Object.create()</code>；</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Create</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\n    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj  <span class="token comment">//后面调用相当于F.prototype.name直接取obj.name</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">&#39;haha&#39;</span><span class="token punctuation">}</span>\n<span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token function">Create</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>\nobj2<span class="token punctuation">.</span>name   <span class="token comment">// &#39;haha&#39;</span>\n</code></pre></div><h3 id="寄生式继承"><a class="header-anchor" href="#寄生式继承" aria-hidden="true">#</a> 寄生式继承</h3><p>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式，通过一个函数，传入一个对象，之后创建一个新对象继承该对象，在给该对象新增属性和方法，最后返回该对象，称为寄生式继承；</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">copyObj</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">var</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>  <span class="token comment">//通过create继承</span>\n       <span class="token comment">//以某种方式来增强对象,这里添加了一个新方法;</span>\n    clone<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;hahaha&#39;</span><span class="token punctuation">)</span><span class="token punctuation">}</span> \n    <span class="token keyword">return</span> clone   <span class="token comment">//返回这个对象</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="寄生组合式继承"><a class="header-anchor" href="#寄生组合式继承" aria-hidden="true">#</a> 寄生组合式继承</h3><p>寄生组合式继承强化的部分就是在组合继承的基础上减少一次多余的调用父类的构造函数：</p><p>寄生组合继承是引用类型最理想的继承范式；</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">Animal</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n<span class="token class-name">Dog</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token class-name">Dog</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Dog<span class="token punctuation">;</span>    \n<span class="token comment">// 因为拷贝后被重写了,等于了Animal的,所以需要修复;</span>\n\n<span class="token comment">// object.create相当于</span>\n<span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj\nb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><p><img src="https://notecdn.heny.vip/images/js-15_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81this-05.png" alt="image"></p><p>寄生式组合式继承没有两份父类构造函数的方法；</p><h3 id="extends"><a class="header-anchor" href="#extends" aria-hidden="true">#</a> extends</h3><p>在ES6当中，使用<code>extends</code>直接继承；</p><h2 id="十七、call-apply-bind（修改this指向）"><a class="header-anchor" href="#十七、call-apply-bind（修改this指向）" aria-hidden="true">#</a> 十七、call apply bind（修改this指向）</h2><h3 id="call"><a class="header-anchor" href="#call" aria-hidden="true">#</a> call</h3><p><code>fn.call(this,参数1,参数2)</code> 直接传递参数;</p><h3 id="apply"><a class="header-anchor" href="#apply" aria-hidden="true">#</a> apply</h3><p><code>fn.apply(this,[参数1,参数2])</code> 使用数组形式传参，第二个参数也可以是arguments对象</p><p>第一个填写要修改的this对象，第二个填写参数；</p><div class="language-js"><pre><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">&#39;lishi&#39;</span><span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>\n<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n</code></pre></div><h3 id="bind-ie9"><a class="header-anchor" href="#bind-ie9" aria-hidden="true">#</a> bind IE9+</h3><ol><li><p><code>函数.bind(this，传参)</code>，bind返回一个函数，方便后续传递参数；</p><p>比较灵活，还可以以下调用；</p><p><code>fn.bind(this);</code> 改变this的同时返回一个函数，这个函数再进行传参；</p><p><code>fn.bind(obj,3)(4);</code> 改变完之后直接执行；</p></li><li><p>bind可以直接写在花括号后面，仅对匿名函数和函数表达式起作用；</p></li></ol><p>定时器的this始终指向window，可以通过bind直接修改定时器的this；</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span>\n    <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>函数表达式: var fn = function(){}.bind();</p><p><strong>call、apply和bind的区别</strong></p><p>call、apply调用即直接执行；</p><p>bind函数本身实际使用了柯里化，调用bind会返回一个新的函数，本身不会执行，需要两个小括号才会执行；</p><p>可以根据实际情况选择需要使用哪个方法来调用；</p><h2 id="高频面试题"><a class="header-anchor" href="#高频面试题" aria-hidden="true">#</a> 高频面试题</h2><p>● new 操作符具体干了什么呢 ?</p><p>● 用过哪些设计模式？</p><p>● call() 和 apply() 的区别和作用？</p><p>● JavaScript 对象的几种创建方式？</p><p>● JavaScript 对象的几种继承方式？</p><p>● JavaScript 原型，原型链 ？</p><p>● 如何判断一个对象是否属于某个类？</p><p>● 小贤有一条可爱的狗 (Dog), 它的叫声很好听 (wow), 每次看到主人的时候就会乖 乖叫一声 (yelp), 从这段描述可以得到以下对象：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">wow</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token function">alert</span><span class="token punctuation">(</span>‘wow’<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">yelp</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>小芒和小贤一样原来也有一条可爱的狗，可是突然有一点疯了 (MadDog), 一看到人就会每隔半秒叫一声(wow)地不停叫唤(yelp)。请根据描述，按示例形式用代码来实现。(继承，原型，setInterval)</p>',154);t.render=function(a,p,t,e,c,l){return n(),s("div",null,[o])};export default t;export{p as __pageData};
