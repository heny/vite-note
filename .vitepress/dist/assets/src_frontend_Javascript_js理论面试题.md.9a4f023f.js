import{o as l,c as e,d as i}from"./app.e9024871.js";const r='{"title":"js理论面试题","description":"","frontmatter":{},"headers":[{"level":2,"title":"从url输入到页面展现到底发生了什么","slug":"从url输入到页面展现到底发生了什么"},{"level":2,"title":"TCP三次握手的过程","slug":"tcp三次握手的过程"},{"level":2,"title":"缓存","slug":"缓存"},{"level":2,"title":"Proxy与Object.defineProperty的优劣对比?","slug":"proxy与object-defineproperty的优劣对比"},{"level":2,"title":"前端常见攻击方式","slug":"前端常见攻击方式"},{"level":2,"title":"前端常用跨域方案","slug":"前端常用跨域方案"},{"level":2,"title":"什么是Virtual dom","slug":"什么是virtual-dom"},{"level":2,"title":"前端网站常规优化方案","slug":"前端网站常规优化方案"}],"relativePath":"src/frontend/Javascript/js理论面试题.md","lastUpdated":1620744789121}',p={},a=i('<h1 id="js理论面试题"><a class="header-anchor" href="#js理论面试题" aria-hidden="true">#</a> js理论面试题</h1><h2 id="从url输入到页面展现到底发生了什么"><a class="header-anchor" href="#从url输入到页面展现到底发生了什么" aria-hidden="true">#</a> 从url输入到页面展现到底发生了什么</h2><ul><li>DNS解析，将域名解析成ip地址</li><li>TCP连接，TCP三次握手</li><li>浏览器发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面 <ol><li>解析HTML，构建DOM树</li><li>解析CSS，生成CSS规则树</li><li>合并DOM树和CSS规则，生成render树</li><li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li><li>绘制render树（paint），绘制页面像素信息</li></ol></li><li>断开连接，TCP四次挥手；</li></ul><h2 id="tcp三次握手的过程"><a class="header-anchor" href="#tcp三次握手的过程" aria-hidden="true">#</a> TCP三次握手的过程</h2><p>TCP握手协议</p><p>在TCP/IP协议中,TCP协议提供可靠的连接服务,采用三次握手建立一个连接.</p><p>第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认；</p><p>SYN：同步序列编号(Synchronize Sequence Numbers)</p><p>第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态；</p><p>第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.</p><p>三次握手的步骤：（抽象派）</p><p>客户端：hello，你是server么？</p><p>服务端：hello，我是server，你是client么</p><p>客户端：yes，我是client</p><p>四次挥手的步骤：（抽象派）</p><p>主动方：我已经关闭了向你那边的主动通道了，只能被动接收了</p><p>被动方：收到通道关闭的信息</p><p>被动方：那我也告诉你，我这边向你的主动通道也关闭了</p><p>主动方：最后收到数据，之后双方无法通信</p><h2 id="缓存"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> 缓存</h2><p>缓存分为前端缓存和后端缓存；</p><p>网络发起请求就是三个步骤：请求，处理，响应；</p><p>处理为后端处理，前端为请求和响应；</p><p>缓存主要包含memory cache和disk Cache；可以在network-size查看到，如果是大小多少k就是网络请求，如果是from memory cache或者from disk Cache和from ServiceWorker；</p><p>优先级是，由上到下寻找，找到即返回，找不到则继续寻找；</p><ol><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>网络请求</li></ol><p>memory cache是内存中的缓存，disk cache是硬盘中的缓存，会先读内存，再读硬盘；几乎所有的网络请求资源都会被浏览器放进memory cache，但是关闭浏览器时，便会失效，失效之后则会访问disk cache；</p><p>memory cache是浏览器为了加快读取缓存速度而进行的自身优化的行为，不受开发者控制，也不受协议头的约束；</p><p>service worker是由开发者编写的额外的脚本，缓存独立；</p><p>平时最熟悉的是disk cache，也http cache，http协议头都分为disk cache的范畴；</p><p>disk cache又分为强制缓存和协商缓存(比对缓存)；</p><p>强制缓存是指客户端请求后，会先访问缓存数据库看缓存是否存在，如果存在直接返回，不存在则请求真的服务器，响应后再存入数据库；</p><p>强制缓存直接减少请求次数，提升最大的缓存策略；可以造成强制缓存的字段是cache-control和expires；</p><ul><li>expires 是表示缓存到期时间，是绝对的时间（当前时间+缓存时间）； <ol><li>expires由于是绝对时间，用户可以随意更改本地时间，达到缓存失效，或者由于时差的原因，也会导致失效；</li><li>expires写法比较复杂，字符串多个空格或少个字母都会导致失效</li></ol></li><li>cache-control 是http1.1中增加的字段，表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求；cache-control是相对时间；cache-control常用的值： <ol><li>max-age：最大有效时间</li><li>must-revalidate：</li><li>no-cache：字面意思不要缓存，但实际上还是要求客户端缓存内容的，只是是否使用这个内容由后续的对比来决定；</li><li>no-store：真正意义上的不要缓存，所有内容都不走缓存，包括强制和协商；</li><li>public：所有的内容都可以被缓存（包括客户端和代理服务器，如CDN）；</li><li>private：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值；</li></ol></li></ul><p>缓存小结：</p><p>当浏览器要请求资源时：</p><ol><li><p>调用Service Worker的fetch事件响应</p></li><li><p>查看memory cache</p></li><li><p>查看disk cache。这里又细分：</p><ol><li>如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这里状态码全部是200；</li><li>如果有强制缓存但已失效，使用对比缓存，比较后确定304还是200</li></ol></li><li><p>发送网络请求，等等网络响应</p></li><li><p>把响应内容存入disk cache（如果http头信息可以存的话）</p></li><li><p>把响应内容的 <strong>引用</strong> 存入memory cache（无视HTTP头信息的配置）</p></li><li><p>把响应内容存入Service Worker的Cache Storage（如果Service Worker的脚本调用了cache.put()）</p></li></ol><h2 id="proxy与object-defineproperty的优劣对比"><a class="header-anchor" href="#proxy与object-defineproperty的优劣对比" aria-hidden="true">#</a> Proxy与Object.defineProperty的优劣对比?</h2><p>Proxy的优势如下:</p><ul><li>Proxy可以直接监听对象而非属性</li><li>Proxy可以直接监听数组的变化</li><li>Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的</li><li>Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改</li><li>Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</li></ul><p><code>Object.defineProperty</code>的优势如下:</p><ul><li>兼容性好,支持IE9</li></ul><h2 id="前端常见攻击方式"><a class="header-anchor" href="#前端常见攻击方式" aria-hidden="true">#</a> 前端常见攻击方式</h2><ul><li>XSS攻击 ---- 跨站脚本攻击，向页面中插入恶意脚本执行</li><li>CSRF攻击 --- 跨站请求伪造，冒充用户发送请求</li><li>Sql注入 ---- 在用户输入框输入sql命令进行攻击</li><li>html脚本注入</li></ul><h2 id="前端常用跨域方案"><a class="header-anchor" href="#前端常用跨域方案" aria-hidden="true">#</a> 前端常用跨域方案</h2><ul><li>JSONP跨域（本质是js调用）</li><li>CORS 后台配置</li><li>postMessage 两个window之间的跨域解决方案</li><li>Nginx 反向代理</li></ul><p>跨域是浏览器做出的安全限制，必须同协议、同域名、同端口否则会被浏览器block</p><h2 id="什么是virtual-dom"><a class="header-anchor" href="#什么是virtual-dom" aria-hidden="true">#</a> 什么是Virtual dom</h2><p>用javascript对象结构表示dom树的结构；然后用这个树构建一个真正的DOM树，插到文档当中，当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树的差异，把所记录的差异应用到所构建的真正的dom树上，视图就更新了。virtual dom本质上就是在js和dom之间做了一个缓存；</p><h2 id="前端网站常规优化方案"><a class="header-anchor" href="#前端网站常规优化方案" aria-hidden="true">#</a> 前端网站常规优化方案</h2><p>优化策略：减少请求次数、减小资源大小、提高响应和加载速度、优化资源加载时机、优化加载方式</p><ul><li>合并、压缩、混淆html/css/js文件（webpack实现，减小资源大小）</li><li>Nginx开启Gzip，进一步压缩资源（减小资源大小）</li><li>图片资源使用CDN加速（提高加载速度）</li><li>符合条件的图标做base64处理（减小资源大小）</li><li>样式表放首部、js放尾部（js单线程，会阻塞页面，资源加载方式）</li><li>设置缓存（强缓存和协商缓存，提高加载速度）</li><li>link或者src添加rel属性，设置prefetch或preload可预加载资源（加载时机）</li><li>如果使用了ui组件库，采用按需加载（减小资源大小）</li><li>SPA项目，通过import或者require做路由按需加载（减小资源大小）</li><li>服务端渲染SSR，加快首屏渲染，利于SEO</li><li>页面使用骨架屏，提高首页加载速度</li><li>使用JPEG 2000, JPEG XR, and WebP的图片格式来代替现有的jpeg和png，该页面图片较多时，这点作用非常明显</li><li>使用图片懒加载-lazyload</li></ul>',52);p.render=function(i,r,p,o,c,t){return l(),e("div",null,[a])};export default p;export{r as __pageData};
