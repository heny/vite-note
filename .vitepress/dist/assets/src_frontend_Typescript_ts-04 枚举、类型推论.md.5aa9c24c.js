import{o as n,c as s,d as a}from"./app.1237ae02.js";const p='{"title":"TS-04 枚举、类型推论","description":"","frontmatter":{},"headers":[{"level":2,"title":"一、枚举","slug":"一、枚举"},{"level":3,"title":"索引枚举","slug":"索引枚举"},{"level":3,"title":"字符串枚举","slug":"字符串枚举"},{"level":3,"title":"异构枚举","slug":"异构枚举"},{"level":3,"title":"枚举成员类型和联合枚举类型","slug":"枚举成员类型和联合枚举类型"},{"level":3,"title":"const枚举","slug":"const枚举"},{"level":3,"title":"外部枚举","slug":"外部枚举"},{"level":2,"title":"二、类型推论","slug":"二、类型推论"},{"level":3,"title":"函数类型兼容","slug":"函数类型兼容"},{"level":3,"title":"枚举类型兼容","slug":"枚举类型兼容"},{"level":3,"title":"类的类型兼容","slug":"类的类型兼容"}],"relativePath":"src/frontend/Typescript/ts-04 枚举、类型推论.md","lastUpdated":1615699077417}',t={},e=a('<h1 id="ts-04-枚举、类型推论"><a class="header-anchor" href="#ts-04-枚举、类型推论" aria-hidden="true">#</a> TS-04 枚举、类型推论</h1><h2 id="一、枚举"><a class="header-anchor" href="#一、枚举" aria-hidden="true">#</a> 一、枚举</h2><blockquote><p>常用枚举场景：定义接口返回的code码，对应枚举属性，提高代码的可读性</p></blockquote><h3 id="索引枚举"><a class="header-anchor" href="#索引枚举" aria-hidden="true">#</a> 索引枚举</h3><p>默认值为0开始，也可以指定初始值，初始值也可以设置为常量，也可以是函数计算，当是函数计算时，后面的值就不能够再递增了，需要给定默认值；</p><div class="language-ts"><pre><code><span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token number">2</span>\n<span class="token keyword">const</span> getIndex <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token number">2</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">enum</span> Status <span class="token punctuation">{</span>\n    Uploading <span class="token operator">=</span> test<span class="token punctuation">,</span>\n    Success <span class="token operator">=</span> <span class="token function">getIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    Faild <span class="token operator">=</span> <span class="token number">2</span> <span class="token comment">// 不指定则报错</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="字符串枚举"><a class="header-anchor" href="#字符串枚举" aria-hidden="true">#</a> 字符串枚举</h3><p>字符串枚举只能使用自己枚举下面的成员，不能使用其他枚举中的成员；</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> Message <span class="token punctuation">{</span>\n    Error<span class="token operator">:</span> <span class="token string">&#39;sorry error&#39;</span><span class="token punctuation">,</span>\n    Success<span class="token operator">:</span> <span class="token string">&#39;success&#39;</span><span class="token punctuation">,</span>\n    Fail <span class="token operator">=</span> Error <span class="token comment">// 也可以直接使用成员,</span>\n<span class="token punctuation">}</span>\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Message<span class="token punctuation">.</span>Error<span class="token punctuation">)</span>\n</code></pre></div><h3 id="异构枚举"><a class="header-anchor" href="#异构枚举" aria-hidden="true">#</a> 异构枚举</h3><blockquote><p>既有索引又有字符串的称为异构枚举</p></blockquote><div class="language-ts"><pre><code><span class="token keyword">enum</span> Result <span class="token punctuation">{</span>\n    Faild <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>\n    Success <span class="token operator">=</span> <span class="token string">&#39;success&#39;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>如果不是特别需要，不建议使用异构枚举；</p><h3 id="枚举成员类型和联合枚举类型"><a class="header-anchor" href="#枚举成员类型和联合枚举类型" aria-hidden="true">#</a> 枚举成员类型和联合枚举类型</h3><blockquote><p>当一个枚举类型满足一定的条件的时候，那么枚举的每个成员，以及枚举其本身都可以作为类型来使用</p></blockquote><p>满足的条件：</p><ul><li>不带初始值的枚举：enum E { A }</li><li>值为字符串字面量：enum E { A = &#39;a&#39; }</li><li>值为数值字面量或者带有负值正值都行：enum E { A = -2 }</li></ul><h4 id="枚举成员类型"><a class="header-anchor" href="#枚举成员类型" aria-hidden="true">#</a> 枚举成员类型</h4><div class="language-ts"><pre><code><span class="token keyword">enum</span> Anima <span class="token punctuation">{</span>\n    Dog <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>\n    Cat <span class="token operator">=</span> <span class="token number">2</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">interface</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span>\n    <span class="token keyword">type</span><span class="token operator">:</span> Anima<span class="token punctuation">.</span>Dog<span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> dog<span class="token operator">:</span> Dog <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token keyword">type</span><span class="token operator">:</span> Anima<span class="token punctuation">.</span>Dog\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="联合枚举类型"><a class="header-anchor" href="#联合枚举类型" aria-hidden="true">#</a> 联合枚举类型</h4><blockquote><p>如<code>(number | string)</code>就是联合枚举类型</p></blockquote><div class="language-ts"><pre><code><span class="token keyword">enum</span> Status <span class="token punctuation">{</span>\n    Off<span class="token punctuation">,</span>\n    On\n<span class="token punctuation">}</span>\n<span class="token keyword">interface</span> <span class="token class-name">Light</span> <span class="token punctuation">{</span>\n    status<span class="token operator">:</span> Status\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> light<span class="token operator">:</span> Light <span class="token punctuation">{</span>\n    status<span class="token operator">:</span> Status<span class="token punctuation">.</span>Off\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="const枚举"><a class="header-anchor" href="#const枚举" aria-hidden="true">#</a> const枚举</h3><blockquote><p>在枚举前面添加const，定义该枚举被编译后值为常量，不再为对象里面取值了，其他成员也都会在编译时被删除</p></blockquote><p>枚举值编译完之后就是一个真实的对象，当使用const定义枚举之后编译的就直接是常量了；</p><div class="language-ts"><pre><code><span class="token keyword">const</span> <span class="token keyword">enum</span> Status <span class="token punctuation">{</span>\n    Success <span class="token operator">=</span> <span class="token number">200</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> <span class="token constant">S</span> <span class="token operator">=</span> Status<span class="token punctuation">.</span>Success\n<span class="token comment">// 编译之后直接是var s = 200</span>\n</code></pre></div><h3 id="外部枚举"><a class="header-anchor" href="#外部枚举" aria-hidden="true">#</a> 外部枚举</h3><p>外部枚举使用<code>declare enum</code>定义的枚举类型</p><div class="language-ts"><pre><code><span class="token keyword">declare</span> <span class="token keyword">enum</span> Directions <span class="token punctuation">{</span>\n    Up<span class="token punctuation">,</span>\n    Down<span class="token punctuation">,</span>\n    Left<span class="token punctuation">,</span>\n    Right\n<span class="token punctuation">}</span>\n\n</code></pre></div><p>declare定义的类型只会用于编译检查，编译结果中会被删除；</p><blockquote><p>ts的枚举类型的概念来源C#</p></blockquote><h2 id="二、类型推论"><a class="header-anchor" href="#二、类型推论" aria-hidden="true">#</a> 二、类型推论</h2><p>当定义一个变量不给类型时，ts会自动帮我们分配类型，例子如下：</p><div class="language-ts"><pre><code><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">&#39;haha&#39;</span>\nstr <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// 报错,已经推断出是string类型</span>\n</code></pre></div><ul><li>多类型联合</li></ul><div class="language-ts"><pre><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">]</span>\narr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">]</span> <span class="token comment">// 报错,因为前者被默认推论出是(string | number)[]</span>\n</code></pre></div><p>当使用window对象时，需要在ts文件中引入dom库；</p><div class="language-json"><pre><code><span class="token comment">// tsconfig.json</span>\n<span class="token punctuation">{</span>\n    <span class="token property">&quot;lib&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;dom&quot;</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="函数类型兼容"><a class="header-anchor" href="#函数类型兼容" aria-hidden="true">#</a> 函数类型兼容</h3><ul><li>参数个数：要求等号右边的参数个数必须小于等于等号左边的参数个数</li></ul><div class="language-ts"><pre><code><span class="token keyword">let</span> <span class="token function-variable function">x</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">0</span>\n<span class="token keyword">let</span> <span class="token function-variable function">y</span> <span class="token operator">=</span> <span class="token punctuation">(</span>b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> c<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">0</span>\ny <span class="token operator">=</span> x <span class="token comment">// 正常</span>\nx <span class="token operator">=</span> y <span class="token comment">// 报错</span>\n</code></pre></div><ul><li>参数类型，必须一一对应</li></ul><h3 id="枚举类型兼容"><a class="header-anchor" href="#枚举类型兼容" aria-hidden="true">#</a> 枚举类型兼容</h3><p>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容，不同枚举类型之间是不兼容的，比如：</p><div class="language-ts"><pre><code><span class="token keyword">enum</span> Status <span class="token punctuation">{</span> On<span class="token punctuation">,</span> Off <span class="token punctuation">}</span>\n<span class="token keyword">enum</span> Anima <span class="token punctuation">{</span> Dog<span class="token punctuation">,</span> Cat <span class="token punctuation">}</span>\n<span class="token keyword">let</span> s <span class="token operator">=</span> Status<span class="token punctuation">.</span>On\ns <span class="token operator">=</span> Anima<span class="token punctuation">.</span>Dog\n</code></pre></div><h3 id="类的类型兼容"><a class="header-anchor" href="#类的类型兼容" aria-hidden="true">#</a> 类的类型兼容</h3><p>类主要是检测实例上的成员类型是否相同，如果相同则可以正常赋值，如果不相同则报错</p><p>如果是私有成员或者是有受保护成员，有这两个成员会对类的类型兼容造成影响，如果一个类包含一个私有成员，那么用来赋值的值也必须包含来自同一个类的私有成员</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">ParentClass</span> <span class="token punctuation">{</span>\n  <span class="token keyword">private</span> age<span class="token operator">:</span> <span class="token builtin">number</span>\n  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">class</span> <span class="token class-name">ChildrenClass</span> <span class="token keyword">extends</span> <span class="token class-name">ParentClass</span><span class="token punctuation">{</span>\n  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">class</span> <span class="token class-name">OtherClass</span> <span class="token punctuation">{</span>\n  <span class="token keyword">private</span> age<span class="token operator">:</span> <span class="token builtin">number</span>\n  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> parent5<span class="token operator">:</span> ParentClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChildrenClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> other<span class="token operator">:</span> ParentClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OtherClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 报错，不是继承来的age属性</span>\n\n</code></pre></div>',49);t.render=function(a,p,t,o,c,l){return n(),s("div",null,[e])};export default t;export{p as __pageData};
