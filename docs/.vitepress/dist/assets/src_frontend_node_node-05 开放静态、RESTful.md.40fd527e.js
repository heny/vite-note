import{o as e,c as d,d as o}from"./app.b11e2761.js";const p='{"title":"node-05 开放静态、RESTful","description":"","frontmatter":{},"headers":[{"level":2,"title":"一、扩展node的路由","slug":"一、扩展node的路由"},{"level":2,"title":"二、扩展express的路由","slug":"二、扩展express的路由"},{"level":2,"title":"三、静态资源托管","slug":"三、静态资源托管"},{"level":2,"title":"五、RESTful API：","slug":"五、restful-api："},{"level":2,"title":"六、中间件","slug":"六、中间件"}],"relativePath":"src\\\\frontend\\\\node\\\\node-05 开放静态、RESTful.md","lastUpdated":1612089669951}',l={},a=o('<h1 id="node-05-开放静态、restful"><a class="header-anchor" href="#node-05-开放静态、restful" aria-hidden="true">#</a> node-05 开放静态、RESTful</h1><h2 id="一、扩展node的路由"><a class="header-anchor" href="#一、扩展node的路由" aria-hidden="true">#</a> 一、扩展node的路由</h2><ol><li><p><code>res.statusCode = 200</code>， 设置状态码</p></li><li><p><code>res.statusMessage = &#39;ok&#39;</code>； 设置状态描述</p></li><li><p><code>res.setHeader(&#39;content-type&#39;,&#39;text/html&#39;)</code>；</p><p>告诉浏览器接收的内容是什么类型的；</p><p>还可以设置响应里面的内容；</p><p>text/plain 纯文本；</p></li></ol><p>上面三种都是res.writeHead的分开写法；</p><h2 id="二、扩展express的路由"><a class="header-anchor" href="#二、扩展express的路由" aria-hidden="true">#</a> 二、扩展express的路由</h2><ol><li><code>res.json()</code>；输出json对象；</li><li><code>res.send(JSON.stringify())</code>；输入json字符串；</li><li><code>res.set()</code>；设置浏览器文件类型；</li><li><code>res.status()</code>；设置状态码；可以直接链式调用send；</li></ol><h2 id="三、静态资源托管"><a class="header-anchor" href="#三、静态资源托管" aria-hidden="true">#</a> 三、静态资源托管</h2><ol><li><p><code>app.use([path],express.static(path))</code>；</p><p>第二个写要开放的目录，建议写绝对路径，可以自动查询index.html；</p><p>第一个可选，可以写一个路由，访问后面的目录需要带上这个路由；</p></li><li><p><code>app.use((req,res)=&gt;{})</code>； 等同于<code>app.all(&#39;*&#39;)</code>；</p></li></ol><h2 id="五、restful-api："><a class="header-anchor" href="#五、restful-api：" aria-hidden="true">#</a> 五、RESTful API：</h2><ol><li><p>传统设计路由的形式: 形容词+名词</p><div class="language-"><pre><code>get  /addbook\nget  /book\nget  /doaddbook\nget  /dodelbook\nget  /doupdatebook\n</code></pre></div><p>RESTful: 这个东西就是去描述 路由应该如何设计</p></li><li><p>RESTful这个标准 把一些路由当中的形容词给去了。用 method请求方法表示</p><p>GET：读取（Read）</p><div class="language-"><pre><code>get  /book/get\n</code></pre></div><p>POST：新建（Create）</p><div class="language-"><pre><code>post /book/post\n</code></pre></div><p>PUT：更新（Update）</p><div class="language-"><pre><code>put  /book/put\n</code></pre></div><p>PATCH：更新（Update），通常是部分更新</p><div class="language-"><pre><code>patch /book\n</code></pre></div><p>DELETE：删除（Delete）</p><div class="language-"><pre><code>delete /book\n       /book?id=1\n       /book/1\n</code></pre></div></li></ol><h2 id="六、中间件"><a class="header-anchor" href="#六、中间件" aria-hidden="true">#</a> 六、中间件</h2><blockquote><p>每一个中间都有自己的一些含义</p></blockquote><p>在express所有的回调函数，都可以称为中间件，中间件可以理解为工厂当中的车间。</p><ul><li><p>内置中间件</p></li><li><p>第三方的</p></li><li><p>自定义中间件</p><p>其实我们定义的路由都可是中间件</p><p>app.get(&#39;/book&#39;) app.post(&#39;/user&#39;)... 都是中间件</p></li><li><p>使用中间件特定的语法</p><div class="language-js"><pre><code></code></pre></div></li></ul><p>app.use((req, res, next) =&gt; { // 这里可以做一些处理 next() // 必须调用next函数，否则不会往下面走了 }) ```</p><pre><code>使用中间件和定义路由很相像，只要匹配成功并且send了，就不会再往下匹配 。\n</code></pre>',16);l.render=function(o,p,l,s,r,t){return e(),d("div",null,[a])};export default l;export{p as __pageData};
